---
title: "Adding a source"
slug: "add-source"
hidden: false
createdAt: "2022-05-05T11:05:26.145Z"
updatedAt: "2022-05-05T11:05:00.162Z"
sidebar_position: 2
---

In this guide, we outline the steps needed to add a new integration to Vital. We will use [Withings Cloud API](https://developer.withings.com) as an example, but the same steps apply to other data sources having an OAuth2 based API. We will release guides for non-oauth based sources as well.

### Adding the Source

The first step is to add a row to the `source` table in the db. For Withings, that looks like this:

```json
{
    "name": "Withings",
    "slug": "withings",
    "description": "Smart Scales, Watches and Health Monitors",
    "logo": "public/url/to/withings/logo.png",
    "oauth_url": "https://account.withings.com/oauth2_user/authorize2",
    "auth_type": "oauth",
    "source_type": "device",
    "is_active": false
}
```

* The `oauth_url` is the URL used to start the OAuth2 authorization process.
* `auth_type` is set to `oauth` in this case. Other values can be `password` for a source that use password based authentication.
* `source_type` is `device`, meaning that this API collects data generated by wearable devices.
* `is_active` controls whether the source can be used within Vital. This value should be set to `true` once the integration is ready for testing.

After adding the source, we can now implement the client.

### Implementing the client

All clients live in the [clients package](https://github.com/adeptlabs/vital-mono/tree/main/vital-background-pull/vital_core/clients). A client integrates with an external API and handles authentication and data fetching independently from the rest of the system.

#### Authentication

The Withings auth helper is implemented [here](https://github.com/adeptlabs/vital-mono/blob/main/vital-background-pull/vital_core/clients/withings/auth.py). The scheleton of an auth helper looks like this:

```python
from vital_core.clients.auth import AuthHelper

class WithingsAuth(AuthHelper):
    def __init__(self, connected_source: ConnectedSourceDecrypted):
        """
        Here, a connected source represents the connection between
        a Vital user and their Withings account. It holds credentials
        used to connect to Withings API on behalf of this particular Vital user.
        """
        super().__init__(connected_source)

    async def generate_new_tokens(self) -> Tokens:
        """
        This method is used to refresh the access tokens once they expire.
        """
        pass

    @staticmethod
    async def generate_oauth_link(
        base_oauth_link: str, token: str
    ) -> Tuple[str, Mapping]:
        """
        This method generates the link that starts the OAuth2 authorization flow.
        The specifics of how to create this link is source-specific.
        As an example, for Withings the documentation is here:
        https://developer.withings.com/api-reference/#operation/oauth2-authorize
        """
        pass

    @staticmethod
    async def get_access_token_from_oauth(
        code: str, redirect_uri: str, state: str, oauth_info: Mapping = {}
    ) -> Optional[Tokens]:
        """
        This method is called when after the user has been through the authorization flow
        and has granted access to Vital. Here we request an access token.
        As an example, for Withings the documentation is here:
        https://developer.withings.com/api-reference/#operation/oauth2-getaccesstoken
        """
        pass
```

#### API integration

The Withings implementation lives [here](https://github.com/adeptlabs/vital-mono/blob/main/vital-background-pull/vital_core/clients/withings/withings.py). Here we handle all the calls to the third-party API. At a minimum, it looks like this:

```python
class WithingsClient:
    @staticmethod
    async def exchange_access_token(
        code: str,
        redirect_uri: str,
        grant_type: str = "authorization_code",
        state: str = "",
    ) -> Tokens:
        """
        This method exchanges the information received by the OAuth2 flow
        for access and refresh tokens. It is generally called by
        get_access_token_from_oauth()
        """
        pass

    @staticmethod
    async def refresh_access_token(
        refresh_token: str,
    ) -> Tokens:
        """
        This method implements the logic to refresh tokens upon expiry.
        """
        pass

    # Here we add any other method needed to fetch data from the API.
    # For a full example, please refer to our existing integrations in the codebase.
```

#### Adding the schemas

Schemas are mappings from the API's responses, usually JSON, to pydantic models. Pydantic models are useful
for providing typing and validation on top of what otherwise would be generic JSON objects. All schemas for the
data sources live [here](https://github.com/adeptlabs/vital-mono/tree/main/vital-background-pull/vital_core/schemas/provider_schemas).

Using again Withings as an example, the schema of an activity recorded by a Withings device looks like this:

```python
class WithingsActivity(BaseModel):
    date: str
    timezone: str
    deviceid: Optional[str]
    hash_deviceid: Optional[str]
    brand: int
    is_tracker: bool
    steps: Optional[int]
    distance: Optional[float]
    elevation: Optional[float]
    soft: Optional[int]
    moderate: Optional[int]
    intense: Optional[int]
    active: Optional[int]
    calories: Optional[float]
    totalcalories: float
    hr_average: Optional[int]
    hr_min: Optional[int]
    hr_max: Optional[int]
    hr_zone_0: Optional[int]
    hr_zone_1: Optional[int]
    hr_zone_2: Optional[int]
    hr_zone_3: Optional[int]

    def parse_to_activity_v2_create(
        self,
        priority_id: int,
        user_id: UUID,
        source_id: int,
    ) -> ActivityV2Create:
        """
        This method returns an object that can be stored in the Vital DB.
        """
        pass

    def parse_to_activity(
        self,
        id: UUID,
        user_id: UUID,
        source: Optional[ClientFacingSource],
    ) -> ClientFacingActivity:
        """
        This method returns the object in the schema used by the
        customer facing Vital API.
        """
        pass
```

##### Note on provider_id

Schemas have the concept of a `provider_id`. This is the ID that the provider gives to the specific activity, workout, sleep or other type of data. Some APIs, e.g. Strava, return this unique ID in the API response. Others, e.g. Withings, do not return it. In this case, we generate one, usually by hashing the whole data point:

```python
def parse_to_activity_v2_create(
    self,
    priority_id: int,
    user_id: UUID,
    source_id: int,
) -> ActivityV2Create:
    data = jsonable_encoder(self)
    provider_id = hashlib.md5(
        (json.dumps(data, sort_keys=True).encode())
    ).hexdigest()
    ...
```

In case the API does not provide unique IDs for data points, the logic of generating `provider_id`s is up to you, as long as they're unique. This ID is also useful for measurements spanning multiple database tables. For example, a measurement of blood pressure has a systolic pressure, diastolic pressure and a heart rate pulse. The heart rate pulse is stored in a different table, so it is important that the rows share the same `provider_id` so that the whole measurement can be retrieved from the database.

### Implement the provider

The [providers package](https://github.com/adeptlabs/vital-mono/tree/main/vital-background-pull/vital_core/providers) is where the integration between the third-party API client and the rest of the Vital system takes place.

The base class of a provider looks like this:

```python
class WithingsProvider(Provider):
    def __init__(
        self,
    ) -> None:
        super().__init__(
            Providers.WITHINGS,
            historical_data_handler=WithingsHistoricalDataHandler(),
            daily_data_handler=WithingsDailyDataHandler(),
            webhook_handler=WithingsWebhookHandler(),
            transformer=WithingsTransformer(),
        )

    @property
    def supported_resources(self) -> List[Resource]:
        """
        This is the list of resources supported by the provider.
        """
        return [Resource.ACTIVITY, Resource.BODY, Resource.SLEEP, Resource.WORKOUTS]

    @property
    def backfill_maximum_days(self) -> int:
        """
        This is the maximum amount of days we fetch data from.
        For example, here we fetch the week of data prior to the moment
        of connection with Vital.
        """
        return 7
```

#### Historical handler

The historical handler fetches data that was generated prior to connecting the user to Vital. The methods follow the same logic:

* Get the OAuth2 tokens from the db.
* Initialize the source client.
* Fetch the data.
* Upsert the data to the db.

For a reference implementation, you can check [here](https://github.com/adeptlabs/vital-mono/blob/main/vital-background-pull/vital_core/providers/withings/historical.py).

#### Daily handler

The daily handler fetches data that is generated after the user is connected to Vital. We use a polling mechanism with an interval scheduled between 10 and 15 min. The logic is the same as the historical handler.

For a reference implementation, you can check [here](https://github.com/adeptlabs/vital-mono/blob/main/vital-background-pull/vital_core/providers/oura/daily.py).

#### Webhook handler

The webhook handler is for APIs that implements webhook to notify us when new data is available. This is of course a better approach than having us polling the API, but not all APIs provide that. If an API provides webhooks, we implement this handler. Otherwise, we implement the daily handler.

For a reference implementation, you can check [here](https://github.com/adeptlabs/vital-mono/blob/main/vital-background-pull/vital_core/providers/withings/webhooks.py).

#### Transformer

The transformer is used to parse data into the format required by the customer facing API. It usually uses
the method already implemented in the schema models. For an example implementation, check [here](https://github.com/adeptlabs/vital-mono/blob/main/vital-background-pull/vital_core/providers/withings/transformer.py).

### Activating the provider

After going to the previous steps, we are ready to "activate" the provider. This consists in the following steps:

* In the [providers.py schema file](https://github.com/adeptlabs/vital-mono/blob/main/vital-background-pull/vital_core/schemas/providers.py), add the new provider to the `Providers` and `OAuthProviders` enums.
* In the `source` db table, change `is_active` to `true` in the row you added in the first step.

### Testing the integration

You can test the integration end-to-end through the following steps:

1. [Create a connected source](/contributing/run-locally#creating-a-connected-source).
2. Head over to the database - you should see data coming in from the historical fetch.
3. Use [Vital API](/welcome/quickstart#making-api-requests) to fetch data.
